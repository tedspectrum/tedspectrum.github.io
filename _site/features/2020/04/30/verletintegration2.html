<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Verlet Integration 2</title>
  <meta name="description" content="Verlet Integration 2Following along with a video from Youtube by "Coding Math"  ">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://tedspectrum.github.io/features/2020/04/30/verletintegration2.html">
  <link rel="alternate" type="application/rss+xml" title="Ted Spectrum" href="http://tedspectrum.github.io/feed.xml">
  
  
  <style>
  .app {
    font-size: 1.5rem;
  }

  canvas {
    display: block;
    top: 0px;
    left: 0px;
    border: 1px solid black;
  }
</style>

  
</head>


  <body>
    <header class="site-header">
    <div class="wrapper">
      <h1><a href="/" id="top">Ted Spectrum</a></h1>
    </div>
    </header>
    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Verlet Integration 2</h1>
    <p class="post-meta"><time datetime="2020-04-30T00:00:00+01:00" itemprop="datePublished">Apr 30, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    
<h1>Verlet Integration 2</h1>
<p>Following along with a video from Youtube by "Coding Math"</p>
<div class="app">
  <canvas id="canvas" width="320" height="240"></canvas>
</div>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">
  <div class="wrapper">
    <p><a href="#top">Top</a></p>
  </div>
</footer>


<script>
  window.onload = function () {
    var canvas = document.getElementById("canvas"),
      context = canvas.getContext("2d"),
      width = canvas.width,
      height = canvas.height,
      worldWidth = 3200,
      worldHeight = 2400,
      scaleX = width / worldWidth,
      scaleY = height / worldHeight,
      points = [],
      sticks = [],
      timeElapsed = 0,
      timeNow = 0,
      timeLast = 0,
      bounce = 0.9
      gravity = 0.5,
      friction = 0.995;
    points.push({
      x: 120,
      y: 120,
      oldx: 110,
      oldy: 110
    },
      {
        x: 400,
        y: 120,
        oldx: 400,
        oldy: 120
      },
      {
        x: 400,
        y: 400,
        oldx: 440,
        oldy: 360
      },
      {
        x: 120,
        y: 400,
        oldx: 120,
        oldy: 400
      }
    );
    sticks.push(
      { p0: points[0], p1: points[1] },
      { p0: points[1], p1: points[2] },
      { p0: points[2], p1: points[3] },
      { p0: points[3], p1: points[0] },
      { p0: points[0], p1: points[2] },
      //{ p0: points[1], p1: points[3] }
    )
    //canvas.addEventListener('click', onClick);
    //console.log(points, sticks);
    for (var si = 0; si < sticks.length; si++) {
      // set initial length of each stick
      sticks[si].length = distance(sticks[si].p0, sticks[si].p1);
    }
    update(0);

    function distance(p0, p1) {
      var dx = p1.x - p0.x,
        dy = p1.y - p0.y;
      // Pythagoras h2 = a2 + b2
      return Math.sqrt(dx * dx + dy * dy);
    }
    /*
    function onClick(e) {
      points.push({
        x: e.offsetX,
        y: e.offsetY,
        oldx: e.offsetX - 2,
        oldy: e.offsetY - 2
      })
      //console.log(e.offsetX, e.offsetY);
      if(points.length > 8) {
        points.splice(0,1);
      }
    }
    */

    function update(timeNow) {
      timeElapsed = timeElapsed + timeNow - timeLast;
      if (timeElapsed > 50) {
        // slow it down
        // context.clearRect(0, 0, width, height);
        updatePoints();
        for (var i = 0; i < 3; i++) {
          constrainPoints();
          updateSticks();
        }
        renderPoints();
        renderSticks();
        timeLast = timeNow;
        timeElapsed = 0;
      }
      //console.log(points, sticks);
      window.requestAnimationFrame(update);
    }

    function updateSticks() {
      var s, dx, dy, distance, difference, percent, offsetX, offsetY;
      for (var i = 0; i < sticks.length; i++) {
        s = sticks[i];
        dx = s.p1.x - s.p0.x;
        dy = s.p1.y - s.p0.y;
        distance = Math.sqrt(dx * dx + dy * dy);
        difference = s.length - distance;
        (difference !== 0) ? percent = difference / distance / 2 : percent = 0;
        //console.log(difference, percent);
        offsetX = dx * percent;
        offsetY = dy * percent;
        s.p0.x = s.p0.x - offsetX;
        s.p0.y = s.p0.y - offsetY;
        s.p1.x = s.p1.x + offsetX;
        s.p1.y = s.p1.y + offsetY;
      }
    }
    function updatePoints() {
      var p, i, vx, vy;
      for (i = 0; i < points.length; i++) {
        p = points[i];
        vx = (p.x - p.oldx) * friction;
        vy = (p.y - p.oldy) * friction;
        p.oldx = p.x;
        p.oldy = p.y;
        p.x += vx;
        p.y += vy;
        p.y += gravity;
      }
    }
    function constrainPoints() {
      var p, i, vx, vy;
      for (i = 0; i < points.length; i++) {
        p = points[i];
        vx = (p.x - p.oldx) * friction;
        vy = (p.y - p.oldy) * friction;

        if (p.x > worldWidth) {
          p.x = worldWidth;
          p.oldx = p.x + vx * bounce;
        }
        else if (p.x < 0) {
          p.x = 0;
          p.oldx = p.x + vx * bounce;
        }
        if (p.y > worldHeight) {
          p.y = worldHeight;
          p.oldy = p.y + vy * bounce;
        }
        else if (p.y < 0) {
          p.y = 0;
          p.oldy = p.y + vy * bounce;
        }
      }
    }
    function renderPoints() {
      var p, i, doublePI = Math.PI * 2;
      // clear all
      context.clearRect(0, 0, width, height);
      // draw all
      for (i = 0; i < points.length; i++) {
        p = points[i];
        context.beginPath();
        context.arc(Math.round(p.x * scaleX), Math.round(p.y * scaleY), 5, 0, doublePI);
        context.fill();
      }
    }
    function renderSticks() {
      var s, i;
      context.beginPath();
      for (i = 0; i < sticks.length; i++) {
        s = sticks[i];
        if (!s.hidden) {
          context.moveTo(Math.round(s.p0.x * scaleX), Math.round(s.p0.y * scaleY));
          context.lineTo(Math.round(s.p1.x * scaleX), Math.round(s.p1.y * scaleY));
        }
      }
      context.stroke();
    }
  };
</script>



  </body>

</html>
