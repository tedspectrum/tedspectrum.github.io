---
layout: post
title:  "SVG Rectangle with controllable corners 2"
scripts: 
  - url: "https://cdn.jsdelivr.net/npm/vue@2.6.0/dist/vue.js"
    type: "absolute"
categories: [features]
inlinestyle: >
  <style>
  .app {
    font-size: 1.5rem;
  }
  .app svg {
      border: 1px solid black;
  }
  .hidden {
    display: none;
  }
  </style>
inlinescript: > 
  <script>
  const app = new Vue({
    el: '#postapp',
    data: {
      activeRectIndex: 0,
      activeCorner: "",
      cornerPropertyNames: ["topright", "bottomright", "bottomleft", "topleft"],
      svg: {
        width: 320,
        height: 240,
        title: "rectangle with rounded corner(s)",
        desc: "controllable corners on a SVG rectangle"
      },
      rects: [
      {
        x: 160,
        y: 120,
        path: "",
        title: "one",
        name: "rect1",
        width: 120,
        height: 75,
        topright: { rx: 10, ry: 10 },
        bottomright: { rx: 25, ry: 25 },
        bottomleft: { rx: 5, ry: 5 },
        topleft: { rx: 30, ry: 30 },
        strokeWidth: "2px",
        stroke: "gray",
        fill: "lightskyblue"
      },
      {
        x: 240,
        y: 50,
        path: "",
        title: "two",
        name: "rect2",
        width: 60,
        height: 40,
        topright: { rx: 10, ry: 10 },
        bottomright: { rx: 10, ry: 10 },
        bottomleft: { rx: 0, ry: 0 },
        topleft: { rx: 15, ry: 15 },
        strokeWidth: "2px",
        stroke: "gray",
        fill: "aqua"
      }
      ]
    },
    computed: {
      cornerRx: function() {
        let ret = 0;
        if (this.activeRectIndex !== "" 
          && (this.cornerPropertyNames.includes(this.activeCorner))) {
          ret = this.rects[this.activeRectIndex][this.activeCorner].rx;        
        }
        return ret;
      },
      cornerRy: function() {
        let ret = 0;
        if (this.activeRectIndex !== "" 
          && (this.cornerPropertyNames.includes(this.activeCorner))) {
          ret = this.rects[this.activeRectIndex][this.activeCorner].ry;        
        }
        return ret;
      }
    },
    methods: {
      onChange: function(e) {
        let val = Math.round(e.target.value),
          active;
        if (this.activeRectIndex !== "") {
          active = this.rects[this.activeRectIndex];       
          switch(e.target.id) {
            case "width": active.width = val; break;
            case "height": active.height = val; break;
            case "rx":
              if(this.cornerPropertyNames.includes(this.activeCorner)) {
                active[this.activeCorner].rx = val;
              }
              break;
            case "ry":             
              if(this.cornerPropertyNames.includes(this.activeCorner)) {
                active[this.activeCorner].ry = val;
              }
              break;
          }
        }
      },
      getCornerArcPath: function(rx, ry, pos) {
        // corners drawn with clockwise arcs
        let ret =  "a" + rx + "," + ry + " 0 0 1 ";
        switch(pos) {
          case "topright": ret += rx + "," + ry + " "; break;
          case "bottomright": ret += "-" + rx + "," + ry + " "; break;
          case "bottomleft": ret += "-" + rx + ",-" + ry + " "; break;
          case "topleft": ret += rx + ",-" + ry + " "; break;
        }
        return ret;
      },
      getRectPath: function(rect) {
        let ret = "", topW, bottomW, leftH, rightH;
          topW = rect.width - rect.topright.rx - rect.topleft.rx;
          bottomW = rect.width - rect.bottomright.rx - rect.bottomleft.rx;
          leftH = rect.height - rect.topleft.ry - rect.bottomleft.ry;
          rightH = rect.height - rect.topright.ry - rect.bottomright.ry;
          ret = 
            "M -" + (rect.width / 2) + ",-" + (rect.height / 2) + " "
            + "m " + rect.topleft.rx + ",0 " 
            + "h" + topW + " "
            + this.getCornerArcPath(rect.topright.rx, rect.topright.ry, "topright")
            + "v" + rightH + " " 
            + this.getCornerArcPath(rect.bottomright.rx, rect.bottomright.ry, "bottomright")
            + "h-" + bottomW + " "
            + this.getCornerArcPath(rect.bottomleft.rx, rect.bottomleft.ry, "bottomleft")
            + "v-" + leftH + " "
            + this.getCornerArcPath(rect.topleft.rx, rect.topleft.ry, "topleft")
            + "z";
        //console.log(ret);
        return ret;
      }
    }
  });
  </script>
---
{% raw %}
<div id="postapp" class="app">
  <div class="hidden">
    <!-- cache, give elements ref="" to reference in methods -->
  </div>
  <svg id="appsvg" xml:space="preserve" :width="svg.width" :height="svg.height" zoomAndPan="disable">
    <title v-if="svg.title && svg.title !== ''">{{ svg.title }}</title>
    <desc v-if="svg.desc && svg.desc !== ''">{{ svg.desc }}</desc>
    <defs>
    </defs>
    <g v-for="(rect, index) in rects">
      <g :transform="'translate(' + rect.x + ',' + rect.y + ') skewX(-30)'">
        <path 
          :d="getRectPath(rect)" 
          stroke="none"  
          fill="black"
          transform="scale(1.2) translate(6,6)"
      />
      </g>
    </g>
    <g v-for="(rect, index) in rects">
      <g :transform="'translate(' + rect.x + ',' + rect.y + ') skewX(-30)'">
        <path 
          :d="getRectPath(rect)" 
          stroke="black"
          stroke-width="2"  
          fill="white"
          transform="scale(1.2, 1.2)"
        />
        <path 
          :d="getRectPath(rect)" 
          :stroke="rect.stroke" 
          :stroke-width="rect.strokeWidth" 
          :fill="rect.fill"
        />
      </g>
    </g>
    <g v-for="(rect, index) in rects">
      <g :transform="'translate(' + rect.x + ',' + rect.y + ')'">
        <rect :x="-(rect.width / 2)" :y="-(rect.height / 2)"
          :width="rect.width" :height="rect.height"
          stroke="none" fill="none"></rect>
        <text text-anchor="middle" dominant-baseline="central">{{ rect.title }}</text>
      </g>
    </g>
  </svg>
  <div>
    <label for="rectname">Rectangle</label>
    <select v-model="activeRectIndex" id="rectindex" name="rectname">
      <option value="0">Please select one</option>
      <template v-for="(rect, index) in rects">
        <option :value="index">{{ rect.name }}</option>
      </template>
    </select>   
  </div>
  <div>
    <label for="rectwidth">Width</label>
    <input type="range" id="width" name="rectwidth" min="1"
      @change="onChange"
      :max="svg.width" 
      :value="rects[activeRectIndex].width">
  </div>
  <div>
    <label for="rectheight">Height</label>
    <input type="range" id="height" name="rectheight" min="1" 
      @change="onChange"
      :max="svg.height"
      :value="rects[activeRectIndex].height">
  </div>
  <div>
    <label for="cornername">Corner</label>
    <select v-model="activeCorner" name="cornername">
      <option value="">Please select one</option>
      <option value="topleft">Top Left</option>
      <option value="topright">Top Right</option>
      <option value="bottomleft">Bottom Left</option>
      <option value="bottomright">Bottom Right</option>
    </select>
  </div>
  <div>
    <label for="cornerrx">Corner rx</label>
    <input type="range" id="rx" name="cornerrx" min="0" 
      @change="onChange" 
      :max="(rects[activeRectIndex].width / 2)" 
      :value="cornerRx">
  </div>
  <div>
    <label for="cornerry">Corner ry</label>
    <input type="range" id="ry" name="cornerry" min="0"
      @change="onChange" 
      :max="(rects[activeRectIndex].height / 2)" 
      :value="cornerRy">
  </div>
  <div>
</div>
{% endraw %}