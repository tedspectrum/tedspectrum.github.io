---
layout: post
title:  "SVG Rectangle with controllable corners 2"
scripts: 
  - url: "https://cdn.jsdelivr.net/npm/vue@2.6.0/dist/vue.min.js"
    type: "absolute"
categories: [features]
inlinestyle: >
  <style>
  .app {
    font-size: 1.5rem;
  }
  .app svg {
      border: 1px solid black;
  }
  .hidden {
    display: none;
  }
  </style>
inlinescript: > 
  <script>
  const app = new Vue({
    el: '#postapp',
    data: {
      activeRect: {},
      activeCorner: "",
      svg: {
        width: 320,
        height: 240,
        title: "rectangle with rounded corner(s)",
        desc: "controllable corners on a SVG rectangle"
      },
      rect1: {
        x: 160,
        y: 120,
        path: "",
        title: "one",
        width: 120,
        height: 75,
        topright: { rx: 10, ry: 10 },
        bottomright: { rx: 25, ry: 25 },
        bottomleft: { rx: 5, ry: 5 },
        topleft: { rx: 30, ry: 30 },
        strokeWidth: "2px",
        stroke: "gray",
        fill: "lightskyblue"
      },
      rect2: {
        x: 240,
        y: 50,
        path: "",
        title: "two",
        width: 60,
        height: 40,
        topright: { rx: 10, ry: 10 },
        bottomright: { rx: 10, ry: 10 },
        bottomleft: { rx: 0, ry: 0 },
        topleft: { rx: 15, ry: 15 },
        strokeWidth: "2px",
        stroke: "gray",
        fill: "aqua"
      },
      rects: []
    },
    mounted: function() {
      this.rects.push(this.rect1);
      this.rects.push(this.rect2);
      this.$set(this, 'activeRect', this.rect1);
    },
    computed: {
      rect1Path: function() {
        return this.getRectPath(this.rect1);
      },
      cornerRx: function() {
        let ret = 0;
        switch(this.activeCorner) {
          case "topright": ret = this.activeRect.topright.rx; break;
          case "bottomright": ret = this.activeRect.bottomright.rx; break;
          case "bottomleft": ret = this.activeRect.bottomleft.rx; break;
          case "topleft": ret = this.activeRect.topleft.rx; break;
        }
        return ret;
      },
      cornerRy: function() {
        let ret = 0;
        switch(this.activeCorner) {
          case "topright": ret = this.activeRect.topright.ry; break;
          case "bottomright": ret = this.activeRect.bottomright.ry; break;
          case "bottomleft": ret = this.activeRect.bottomleft.ry; break;
          case "topleft": ret = this.activeRect.topleft.ry; break;
        }
        return ret;
      }
    },
    methods: {
      onChange: function(e) {
        switch(e.target.id) {
          case "width": this.activeRect.width = Math.round(e.target.value); break;
          case "height": this.activeRect.height = Math.round(e.target.value); break;
          case "rx": 
            switch(this.activeCorner) {
              case "topright": this.activeRect.topright.rx = Math.round(e.target.value); break;
              case "bottomright": this.activeRect.bottomright.rx = Math.round(e.target.value); break;
              case "bottomleft": this.activeRect.bottomleft.rx = Math.round(e.target.value); break;
              case "topleft": this.activeRect.topleft.rx = Math.round(e.target.value); break;
            }; break;
          case "ry":             
            switch(this.activeCorner) {
              case "topright": this.activeRect.topright.ry = Math.round(e.target.value); break;
              case "bottomright": this.activeRect.bottomright.ry = Math.round(e.target.value); break;
              case "bottomleft": this.activeRect.bottomleft.ry = Math.round(e.target.value); break;
              case "topleft": this.activeRect.topleft.ry = Math.round(e.target.value); break;
            }; break;
        }
      },
      getCornerArcPath: function(rx, ry, pos) {
        // corners drawn with clockwise arcs
        let ret =  "a" + rx + "," + ry + " 0 0 1 ";
        switch(pos) {
          case "topright": ret += rx + "," + ry + " "; break;
          case "bottomright": ret += "-" + rx + "," + ry + " "; break;
          case "bottomleft": ret += "-" + rx + ",-" + ry + " "; break;
          case "topleft": ret += rx + ",-" + ry + " "; break;
        }
        return ret;
      },
      getRectPath: function(rect) {
        let ret = "", topW, bottomW, leftH, rightH;
          topW = rect.width - rect.topright.rx - rect.topleft.rx;
          bottomW = rect.width - rect.bottomright.rx - rect.bottomleft.rx;
          leftH = rect.height - rect.topleft.ry - rect.bottomleft.ry;
          rightH = rect.height - rect.topright.ry - rect.bottomright.ry;
          ret = 
            "M -" + (rect.width / 2) + ",-" + (rect.height / 2) + " "
            + "m " + rect.topleft.rx + ",0 " 
            + "h" + topW + " "
            + this.getCornerArcPath(rect.topright.rx, rect.topright.ry, "topright")
            + "v" + rightH + " " 
            + this.getCornerArcPath(rect.bottomright.rx, rect.bottomright.ry, "bottomright")
            + "h-" + bottomW + " "
            + this.getCornerArcPath(rect.bottomleft.rx, rect.bottomleft.ry, "bottomleft")
            + "v-" + leftH + " "
            + this.getCornerArcPath(rect.topleft.rx, rect.topleft.ry, "topleft")
            + "z";
        //console.log(ret);
        return ret;
      }
    }
  });
  </script>
---
{% raw %}
<div id="postapp" class="app">
  <div class="hidden">
    <!-- cache, give elements ref="" to reference in methods -->
  </div>
  <svg id="appsvg" xml:space="preserve" :width="svg.width" :height="svg.height" zoomAndPan="disable">
    <title v-if="svg.title && svg.title !== ''">{{ svg.title }}</title>
    <desc v-if="svg.desc && svg.desc !== ''">{{ svg.desc }}</desc>
    <defs>
    </defs>
    <g v-for="(rect, index) in rects">
      <g :transform="'translate(' + rect.x + ',' + rect.y + ') skewX(-30)'">
        <path 
          :d="getRectPath(rect)" 
          stroke="none"  
          fill="black"
          transform="scale(1.2) translate(6,6)"
      />
      </g>
    </g>
    <g v-for="(rect, index) in rects">
      <g :transform="'translate(' + rect.x + ',' + rect.y + ') skewX(-30)'">
        <path 
          :d="getRectPath(rect)" 
          stroke="black"
          stroke-width="2"  
          fill="white"
          transform="scale(1.2, 1.2)"
        />
        <path 
          :d="getRectPath(rect)" 
          :stroke="rect.stroke" 
          :stroke-width="rect.strokeWidth" 
          :fill="rect.fill"
        />
      </g>
    </g>
    <g v-for="(rect, index) in rects">
      <g :transform="'translate(' + rect.x + ',' + rect.y + ')'">
        <rect :x="-(rect.width / 2)" :y="-(rect.height / 2)"
          :width="rect.width" :height="rect.height"
          stroke="none" fill="none"></rect>
        <text text-anchor="middle" dominant-baseline="central">{{ rect.title }}</text>
      </g>
    </g>

  </svg>
  <div>
    <label for="rectwidth">Width</label>
    <input @change="onChange" type="range" id="width" name="rectwidth" min="1" :max="svg.width" :value="activeRect.width">
  </div>
  <div>
    <label for="rectheight">Height</label>
    <input @change="onChange" type="range" id="height" name="rectheight" min="1" :max="svg.height" :value="activeRect.height">
  </div>
  <div>
    <label for="cornername">Corner</label>
    <select v-model="activeCorner" name="cornername">
      <option value="">Please select one</option>
      <option value="topleft">Top Left</option>
      <option value="topright">Top Right</option>
      <option value="bottomleft">Bottom Left</option>
      <option value="bottomright">Bottom Right</option>
    </select>
  </div>
  <div>
    <label for="cornerrx">Corner rx</label>
    <input @change="onChange" type="range" id="rx" name="cornerrx" min="0" max="30" :value="cornerRx">
  </div>
  <div>
    <label for="cornerry">Corner ry</label>
    <input @change="onChange" type="range" id="ry" name="cornerry" min="0" max="30" :value="cornerRy">
  </div>
  <div>
</div>
{% endraw %}